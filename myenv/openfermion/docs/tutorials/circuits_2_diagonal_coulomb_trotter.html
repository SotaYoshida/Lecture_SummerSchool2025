
<!DOCTYPE html>


<html lang="ja" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Copyright 2020 The OpenFermion Developers &#8212; Julia言語による原子核構造計算入門</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../_static/documentation_options.js?v=1cf7f4d9"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="../../../../_static/translations.js?v=91613774"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'myenv/openfermion/docs/tutorials/circuits_2_diagonal_coulomb_trotter';</script>
    <link rel="index" title="索引" href="../../../../genindex.html" />
    <link rel="search" title="検索" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ja"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">本文へスキップ</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>トップに戻る</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="バージョン警告"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../../home.html">
  
  
  
  
  
  
    <p class="title logo__title">Julia言語による原子核構造計算入門</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="検索" aria-label="検索" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">検索</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../../home.html">
                    講義の狙いと資料の概要
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">pairing Hamiltonianと多体計算手法</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/Hamiltonian.html">1. pairing Hamiltonian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/FullCI.html">2. Full-CI/厳密対角化</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/HartreeFock.html">3. Hartree-Fock</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/BCS.html">4. BCS (Bardeen-Cooper-Schrieffer)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/MBPT.html">5. Many-Body Perturbation Theory (MBPT)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/CoupledCluster.html">6. Coupled Cluster</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/IMSRG.html">7. In-medium Similarity Renormalization Group (IM-SRG)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/EC.html">8. Emulator/Surrogate model</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">量子計算</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/QuantumComputing.html">9. Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/Pairing_VQE_pennylane.html">10. Pairing HamiltonianのVQE計算 (Pennylane)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/qpe_pennylane.html">11. Pairing HamiltonianのQPE計算 (Pennylane)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../notebooks/Pairing_VQE_pytket.html">12. Pairing Hamiltonianの量子計算 (pytket)</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/SotaYoshida/Lecture_SummerSchool2025" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="ソースリポジトリ"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/SotaYoshida/Lecture_SummerSchool2025/issues/new?title=Issue%20on%20page%20%2Fmyenv/openfermion/docs/tutorials/circuits_2_diagonal_coulomb_trotter.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="問題を報告"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="このページをダウンロード">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../../_sources/myenv/openfermion/docs/tutorials/circuits_2_diagonal_coulomb_trotter.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="ソースファイルをダウンロード"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="PDFに印刷"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="全画面モード"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="ライト"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="ダーク"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="検索" aria-label="検索" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Copyright 2020 The OpenFermion Developers</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> 目次 </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Copyright 2020 The OpenFermion Developers</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#circuits-2-linear-trotter-steps-of-diagonal-coulomb-operators">Circuits 2: Linear Trotter steps of diagonal Coulomb operators</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setup">Setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#electronic-structure-hamiltonians-with-diagonal-coulomb-operators">Electronic structure Hamiltonians with diagonal Coulomb operators</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#generation-of-a-dual-basis-jellium-hamiltonian">Generation of a dual basis jellium Hamiltonian</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#initializing-the-mean-field-state-of-jellium">Initializing the mean-field state of jellium</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hamiltonian-simulation-via-a-trotter-suzuki-product-formula">Hamiltonian simulation via a Trotter-Suzuki product formula</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#application-to-phase-estimation">Application to phase estimation</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="copyright-2020-the-openfermion-developers">
<h1>Copyright 2020 The OpenFermion Developers<a class="headerlink" href="#copyright-2020-the-openfermion-developers" title="Link to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#@title Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
</pre></div>
</div>
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="circuits-2-linear-trotter-steps-of-diagonal-coulomb-operators">
<h1>Circuits 2: Linear Trotter steps of diagonal Coulomb operators<a class="headerlink" href="#circuits-2-linear-trotter-steps-of-diagonal-coulomb-operators" title="Link to this heading">#</a></h1>
<table class="tfo-notebook-buttons" align="left">
  <td>
    <a target="_blank" href="https://quantumai.google/openfermion/tutorials/circuits_2_diagonal_coulomb_trotter"><img src="https://quantumai.google/site-assets/images/buttons/quantumai_logo_1x.png" />View on QuantumAI</a>
  </td>
  <td>
    <a target="_blank" href="https://colab.research.google.com/github/quantumlib/OpenFermion/blob/master/docs/tutorials/circuits_2_diagonal_coulomb_trotter.ipynb"><img src="https://quantumai.google/site-assets/images/buttons/colab_logo_1x.png" />Run in Google Colab</a>
  </td>
  <td>
    <a target="_blank" href="https://github.com/quantumlib/OpenFermion/blob/master/docs/tutorials/circuits_2_diagonal_coulomb_trotter.ipynb"><img src="https://quantumai.google/site-assets/images/buttons/github_logo_1x.png" />View source on GitHub</a>
  </td>
  <td>
    <a href="https://storage.googleapis.com/tensorflow_docs/OpenFermion/docs/tutorials/circuits_2_diagonal_coulomb_trotter.ipynb"><img src="https://quantumai.google/site-assets/images/buttons/download_icon_1x.png" />Download notebook</a>
  </td>
</table><section id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Link to this heading">#</a></h2>
<p>Install the OpenFermion package:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">openfermion</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>git+https://github.com/quantumlib/OpenFermion.git@master#egg<span class="o">=</span>openfermion
</pre></div>
</div>
</div>
</div>
</section>
<section id="electronic-structure-hamiltonians-with-diagonal-coulomb-operators">
<h2>Electronic structure Hamiltonians with diagonal Coulomb operators<a class="headerlink" href="#electronic-structure-hamiltonians-with-diagonal-coulomb-operators" title="Link to this heading">#</a></h2>
<p>When expressed in an arbitrary basis the molecular electronic structure Hamiltonian takes the form
$<span class="math notranslate nohighlight">\(
H = \sum_{pq} h_{pq} a^\dagger_p a_q + \sum_{pqrs} h_{pqrs} a^\dagger_p a^\dagger_q a_r a_s
\)</span><span class="math notranslate nohighlight">\(
where the coefficients \)</span>h_{pq}<span class="math notranslate nohighlight">\( and \)</span>h_{pqrs}<span class="math notranslate nohighlight">\( are determined by integrals taken over the basis functions. Note that this Hamiltonian has \)</span>O(N^4)$ terms which tends to make its simulation challenging on near-term devices.</p>
<p>However, as discussed in <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.8.011044">Phys. Rev. X 8, 011044</a>, by carefully selection of basis function it is possible to obtain a representation that diagonalizes the Coulomb operator, leading to a much simpler Hamiltonian with <span class="math notranslate nohighlight">\(O(N^2)\)</span> terms that can be written as
$<span class="math notranslate nohighlight">\(
H = \sum_{pq} T_{pq} a^\dagger_p a_q + \sum_{pq} V_{pq} a^\dagger_p a_p a^\dagger_q a_q
\)</span>$
This form is derived in <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.8.011044">Phys. Rev. X 8, 011044</a> by using basis functions that are related to a unitary rotation of plane waves. However, plane waves are not the only basis with this property; e.g., see <a class="reference external" href="https://aip.scitation.org/doi/10.1063/1.5007066">JCP 147, 244102</a> for a basis that provides the diagonal form and high accuracy representation of single-molecules.</p>
<p>Being a periodic basis, plane waves are particularly well suited to simulating periodic materials (e.g. solid state LiH instead of single molecule LiH in vacuum). One can use plane waves to also simulate single-molecules with a basis set discretization error that is asymptotically equivalent to Gaussian molecular orbitals; however, in practice for simulating single-molecules one often needs a constant factor more plane waves than Gaussians, and sometimes that constant factor is prohibitive for NISQ applications. In <a class="reference internal" href="circuits_3_arbitrary_basis_trotter.html"><span class="std std-doc">Circuits 3</span></a>, we discuss how a combination of techniques from <a class="reference internal" href="circuits_1_basis_change.html"><span class="std std-doc">Circuits 1</span></a> and this tutorial enable simulation of arbitrary basis electronic structure in low depth. However, this tutorial will focus on representations of the Hamiltonian with a diagonal Coulomb operator. The techniques discussed in this notebook are applicable to any molecular system, whether periodic or not. However, for simplicity this notebook will focus on the simulation of the uniform electron gas, aka &quot;jellium&quot;. Jellium has the same Hamiltonian as an arbitrary molecule but without an external potential (i.e. <span class="math notranslate nohighlight">\(T_{pp}\)</span> is uniform for all <span class="math notranslate nohighlight">\(p\)</span>).</p>
</section>
<section id="generation-of-a-dual-basis-jellium-hamiltonian">
<h2>Generation of a dual basis jellium Hamiltonian<a class="headerlink" href="#generation-of-a-dual-basis-jellium-hamiltonian" title="Link to this heading">#</a></h2>
<p>We begin by generating a small two-dimensional jellium model in the &quot;plane wave dual basis&quot; as in <a class="reference external" href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.8.011044">Phys. Rev. X 8, 011044</a>. Such two-dimensional jellium systems are often studied in the context of the fractional quantum Hall effect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openfermion</span>

<span class="c1"># Set parameters of jellium model.</span>
<span class="n">wigner_seitz_radius</span> <span class="o">=</span> <span class="mf">5.</span> <span class="c1"># Radius per electron in Bohr radii.</span>
<span class="n">n_dimensions</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Number of spatial dimensions.</span>
<span class="n">grid_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Number of grid points in each dimension.</span>
<span class="n">spinless</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Whether to include spin degree of freedom or not.</span>
<span class="n">n_electrons</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Number of electrons.</span>

<span class="c1"># Figure out length scale based on Wigner-Seitz radius and construct a basis grid.</span>
<span class="n">length_scale</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">wigner_seitz_length_scale</span><span class="p">(</span>
    <span class="n">wigner_seitz_radius</span><span class="p">,</span> <span class="n">n_electrons</span><span class="p">,</span> <span class="n">n_dimensions</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">n_dimensions</span><span class="p">,</span> <span class="n">grid_length</span><span class="p">,</span> <span class="n">length_scale</span><span class="p">)</span>

<span class="c1"># Initialize the model and print out.</span>
<span class="n">fermion_hamiltonian</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">jellium_model</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">spinless</span><span class="o">=</span><span class="n">spinless</span><span class="p">,</span> <span class="n">plane_wave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fermion_hamiltonian</span><span class="p">)</span>

<span class="c1"># Convert to DiagonalCoulombHamiltonian type.</span>
<span class="n">hamiltonian</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">get_diagonal_coulomb_hamiltonian</span><span class="p">(</span><span class="n">fermion_hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In the last line above we converted the FermionOperator to a class called DiagonalCoulombHamiltonian which is a special data structure in OpenFermion for representing operators that take the form
$<span class="math notranslate nohighlight">\(
H = \sum_{pq} T_{pq} a^\dagger_p a_q + \sum_{pq} V_{pq} a^\dagger_p a_p a^\dagger_q a_q.
\)</span><span class="math notranslate nohighlight">\(
OpenFermion has implemented Hamiltonian simulation algorithms that are optimized specifically for Hamiltonians of this form. They take as input the OpenFermion data structure DiagonalCoulombHamiltonian, which represents such a Hamiltonian in terms of matrices storing \)</span>T_{pq}<span class="math notranslate nohighlight">\( and \)</span>V_{pq}$.</p>
</section>
<section id="initializing-the-mean-field-state-of-jellium">
<h2>Initializing the mean-field state of jellium<a class="headerlink" href="#initializing-the-mean-field-state-of-jellium" title="Link to this heading">#</a></h2>
<p>Often one would like to begin a simulation of electronic structure in the mean-field state. To do this while keeping operators in the dual basis one needs to apply a rotation of single particle basis functions (see <a class="reference internal" href="circuits_1_basis_change.html"><span class="std std-doc">Circuits 1</span></a>). For arbitrary molecules this would necessitate first computing the canonical orbitals using a Hartree-Fock calculation, perhaps by using <a class="reference external" href="https://github.com/quantumlib/OpenFermion-PySCF">OpenFermion-PySCF</a>. However, since jellium has no external potential the mean-field state is an eigenstate of the one-body term <span class="math notranslate nohighlight">\(\sum_{p, q} T_{pq} a^\dagger_p a_q\)</span>. This term is a quadratic Hamiltonian, so its eigenstates can be prepared by applying a Bogoliubov transformation to a computational basis state. The Bogoliubov transformation changes the basis to one in which the quadratic Hamiltonian has the diagonal form <span class="math notranslate nohighlight">\(\sum_{p} \varepsilon_p b^\dagger_p b_p\)</span>, where the <span class="math notranslate nohighlight">\(b^\dagger_p\)</span> are the creation operators for a new set of orbitals. We'll set the number of electrons to be half the total number of orbitals.</p>
<p>We'll use the OpenFermion class QuadraticHamiltonian to obtain the Bogoliubov transformation matrix. Then, we'll initialize some qubits and create a circuit that applies the transformation to these qubits. Since our algorithms work with linear qubit connectivity, we'll use the <code class="docutils literal notranslate"><span class="pre">LineQubit</span></code> class. We won't bother compiling to Xmon gates for now to keep the circuits simple, but this can be done automatically using the appropriate Cirq methods. We will specify the initial state by passing in a list of the occupied orbitals (which in this case are just the first <code class="docutils literal notranslate"><span class="pre">n_electron</span></code> orbitals).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cirq</span>
<span class="kn">import</span> <span class="nn">openfermion</span>

<span class="c1"># Obtain the Bogoliubov transformation matrix.</span>
<span class="n">quadratic_hamiltonian</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">QuadraticHamiltonian</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">one_body</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">transformation_matrix</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quadratic_hamiltonian</span><span class="o">.</span><span class="n">diagonalizing_bogoliubov_transform</span><span class="p">()</span>

<span class="c1"># Create a circuit that prepares the mean-field state</span>
<span class="n">occupied_orbitals</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_electrons</span><span class="p">)</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">count_qubits</span><span class="p">(</span><span class="n">quadratic_hamiltonian</span><span class="p">)</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">LineQubit</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">)</span>
<span class="n">state_preparation_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">bogoliubov_transform</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">transformation_matrix</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">occupied_orbitals</span><span class="p">))</span>

<span class="c1"># Print circuit.</span>
<span class="n">state_preparation_circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_preparation_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="hamiltonian-simulation-via-a-trotter-suzuki-product-formula">
<h2>Hamiltonian simulation via a Trotter-Suzuki product formula<a class="headerlink" href="#hamiltonian-simulation-via-a-trotter-suzuki-product-formula" title="Link to this heading">#</a></h2>
<p>The goal of Hamiltonian time evolution simulation is to apply the unitary operator <span class="math notranslate nohighlight">\(\exp(-i H t)\)</span> for some time t. A simulation via a product formula proceeds by dividing the total evolution time <span class="math notranslate nohighlight">\(t\)</span> into a finite number of steps <span class="math notranslate nohighlight">\(r\)</span> and performing an approximate simulation of <span class="math notranslate nohighlight">\(\exp(-i H t/r)\)</span> <span class="math notranslate nohighlight">\(r\)</span> times. Each simulation of <span class="math notranslate nohighlight">\(\exp(-i H t/r)\)</span> is called a Trotter step. The unitary <span class="math notranslate nohighlight">\(\exp(-i H t/r)\)</span> is approximated by interleaving simulations of the terms <span class="math notranslate nohighlight">\(H_j\)</span> of a decomposition <span class="math notranslate nohighlight">\(H = \sum_{j=1}^L H_j\)</span>. For example, the first-order symmetric, commonly known as the second-order, Trotter formula is
$<span class="math notranslate nohighlight">\(\exp(-i H t) \approx \prod_{j=1}^L \exp(-i H_j t/2) \prod_{j=L}^1 \exp(-i H_j t/2).\)</span><span class="math notranslate nohighlight">\(
Higher-order product formulas are obtained from this one via a recursive construction. There is also a zeroth-order formula, which corresponds to
\)</span><span class="math notranslate nohighlight">\(\exp(-i H t) \approx \prod_{j=1}^L \exp(-i H_j t).\)</span><span class="math notranslate nohighlight">\(
In our case, the \)</span>H_j<span class="math notranslate nohighlight">\( have the form \)</span>T_{pq} a^\dagger_p a_q + T_{pq}^* a^\dagger_q a_p<span class="math notranslate nohighlight">\( or \)</span>V_{pq} a^\dagger_p a_p a^\dagger_q a_q$.</p>
<p>To construct a circuit for performing time evolution via a product formula, we need to specify the total evolution time, the number of steps to use, and the order of the formula to use. For a fixed evolution time, increasing the number of steps and increasing the order of the formula both yield a more accurate simulation at the cost of increasing the gate count of the circuit. We could also specify an asymmetric Trotter step, or a controlled version, but we won't do that here. We will need to specify what algorithm will be used to compile the Trotter step. There are several options appropriate for DiagonalCoulombHamiltonians.</p>
<p>A key result of <a class="reference external" href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.120.110501">Phys. Rev. Lett. 120, 110501</a> was to introduce a linear connectivity swap network which cycles through configurations in which all qubits are adjacent in at most <span class="math notranslate nohighlight">\(N\)</span> parallel layers of swaps. As shown in that paper, by using fermionc swap gates instead of regular swap gates, one can use this swap network to simulate Trotter steps of an entire DiagonalCoulombHamiltonian. This effectively simulates <span class="math notranslate nohighlight">\(N / 2\)</span> different pairs of terms <span class="math notranslate nohighlight">\(V_{pq} a^\dagger_p a_p a^\dagger_q a_q\)</span> and <span class="math notranslate nohighlight">\(T_{pq} a^\dagger_p a_q + T^*_{pq} a^\dagger_q a_p\)</span> in each layer of gates. By repeating the swap network for <span class="math notranslate nohighlight">\(N\)</span> layers, all terms are simulated exactly once. This is referred to as the <code class="docutils literal notranslate"><span class="pre">LINEAR_SWAP_NETWORK</span></code> Trotter step in OpenFermion.</p>
<p>Another approach to implementing the Trotter step involves simulating all <span class="math notranslate nohighlight">\(\sum_{pq} V_{pq} a^\dagger_p a_p a^\dagger_q a_q\)</span> terms (which commute and thus, this involves no Trotter error) by using the linear swap networks (with normal swap gates), and then performing a basis transformation which diagonalizes the one-body terms so that all of the <span class="math notranslate nohighlight">\(\sum_{pq} T_{pq} a^\dagger_p a_q\)</span> terms can be simulated at once, and then performing another basis transformation to restore the original basis. This method involves more gates in each Trotter step but has less Trotter error, and thus might require fewer Trotter steps to achieve some target accuracy. This is referred to as the <code class="docutils literal notranslate"><span class="pre">SPLIT_OPERATOR</span></code> Trotter step in OpenFermion.</p>
<p>Thus, there are currently two options for simulating DiagonalCoulombHamiltonians, <code class="docutils literal notranslate"><span class="pre">LINEAR_SWAP_NETWORK</span></code> and <code class="docutils literal notranslate"><span class="pre">SPLIT_OPERATOR</span></code>, and they correspond to different orderings of the terms <span class="math notranslate nohighlight">\(H_j\)</span> in the product formula. Different orderings give different results because the <span class="math notranslate nohighlight">\(H_j\)</span> do not all commute. Let's construct a circuit with the <code class="docutils literal notranslate"><span class="pre">LINEAR_SWAP_NETWORK</span></code> method using just one first order Trotter step. We'll insert operations into the circuit using the strategy <code class="docutils literal notranslate"><span class="pre">EARLIEST</span></code> so the printed output will be most compact. Still, the circuit will be longer than the width of this notebook, so we'll print it out transposed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">openfermion.circuits</span> <span class="kn">import</span> <span class="n">trotter</span>

<span class="c1"># Set algorithm parameters.</span>
<span class="n">time</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># Construct circuit</span>
<span class="n">swap_network_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">LINEAR_SWAP_NETWORK</span><span class="p">),</span>
    <span class="n">strategy</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">InsertStrategy</span><span class="o">.</span><span class="n">EARLIEST</span><span class="p">)</span>

<span class="c1"># Print circuit.</span>
<span class="n">swap_network_trotter_step</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Now let's do the same, but using the <code class="docutils literal notranslate"><span class="pre">SPLIT_OPERATOR</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">split_operator_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">SPLIT_OPERATOR</span><span class="p">),</span>
    <span class="n">strategy</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">InsertStrategy</span><span class="o">.</span><span class="n">EARLIEST</span><span class="p">)</span>
<span class="n">split_operator_trotter_step</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">split_operator_trotter_step</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">split_operator_trotter_step</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Let's run these circuits on the simulator that comes with Cirq and compute the energy of the resulting states.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize Cirq simulator.</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Simulator</span><span class="p">()</span>

<span class="c1"># Convert the Hamiltonian to a sparse matrix.</span>
<span class="n">hamiltonian_sparse</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">get_sparse_operator</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>

<span class="c1"># Obtain initial state vector as integer.</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_qubits</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">occupied_orbitals</span><span class="p">)</span>

<span class="c1"># Construct and simulate circuit using the swap network method.</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span> <span class="o">+</span> <span class="n">swap_network_trotter_step</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">)</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">final_state_vector</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy of state obtained with swap network method: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">expectation</span><span class="p">(</span><span class="n">hamiltonian_sparse</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>

<span class="c1"># Construct and simulate circuit using the split-operator method.</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">state_preparation_circuit</span> <span class="o">+</span> <span class="n">split_operator_trotter_step</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">)</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">final_state_vector</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy of state obtained with split-operator method: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">expectation</span><span class="p">(</span><span class="n">hamiltonian_sparse</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Increasing the number of Trotter steps will cause both methods to converge to the same operation, corresponding to an exact simulation. You can play around with the number of Trotter steps to confirm. Note that for NISQ applications one will often be interested in using the zeroth-order Trotter step, also known as the first-order asymmetric Trotter step. We can implement these Trotter steps by setting the order to zero, as we do below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set algorithm parameters.</span>
<span class="n">time</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Construct circuit</span>
<span class="n">swap_network_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">LINEAR_SWAP_NETWORK</span><span class="p">),</span>
    <span class="n">strategy</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">InsertStrategy</span><span class="o">.</span><span class="n">EARLIEST</span><span class="p">)</span>
<span class="n">swap_network_trotter_step</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Note the unusual pattern of fermionic swap networks towards the end. What is happening there is that in the zeroth order step of a <code class="docutils literal notranslate"><span class="pre">LINEAR_SWAP_NETWORK</span></code> style Trotter step, the qubit order is reversed upon output. To avoid this one needs to set an option called <code class="docutils literal notranslate"><span class="pre">omit_final_swaps</span></code>, e.g.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">swap_network_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">LINEAR_SWAP_NETWORK</span><span class="p">,</span>
        <span class="n">omit_final_swaps</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="n">strategy</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">InsertStrategy</span><span class="o">.</span><span class="n">EARLIEST</span><span class="p">)</span>
<span class="n">swap_network_trotter_step</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>One can also have fun compiling arbitrary high-order formulas. Here's the third-order symmetric formula:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span><span class="o">=</span><span class="mi">3</span>
<span class="n">n_steps</span><span class="o">=</span><span class="mi">1</span>
<span class="n">swap_network_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
        <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">LINEAR_SWAP_NETWORK</span><span class="p">),</span>
    <span class="n">strategy</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">InsertStrategy</span><span class="o">.</span><span class="n">EARLIEST</span><span class="p">)</span>
<span class="n">swap_network_trotter_step</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">swap_network_trotter_step</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="application-to-phase-estimation">
<h2>Application to phase estimation<a class="headerlink" href="#application-to-phase-estimation" title="Link to this heading">#</a></h2>
<p>Phase estimation is a procedure that, given access to a controlled unitary and one of its eigenvectors, estimates the phase of the eigenvalue corresponding to that eigenvector. In the context of quantum simulation, this unitary is usually the time evolution operator <span class="math notranslate nohighlight">\(e^{-iHt}\)</span>. Thus if <span class="math notranslate nohighlight">\(H\lvert n\rangle = E_n \lvert n \rangle\)</span>, and we initialize the system in state <span class="math notranslate nohighlight">\(\lvert n \rangle\)</span>, phase estimation would estimate the value <span class="math notranslate nohighlight">\(E_n t / (2\pi)\)</span>. To avoid aliasing of phases, <span class="math notranslate nohighlight">\(t\)</span> should be chosen to be smaller than <span class="math notranslate nohighlight">\(2\pi / \lvert E_n \rvert\)</span>.</p>
<p>The simplest phase estimation circuit measures one bit of the phase in four steps:</p>
<ol class="arabic simple">
<li><p>Perform a Hadamard transform on the control qubit.</p></li>
<li><p>Apply the controlled unitary.</p></li>
<li><p>Perform a Hadamard transform on the control qubit.</p></li>
<li><p>Measure the control qubit.</p></li>
</ol>
<p>Below, we demonstrate the construction of this circuit where the controlled unitary is a controlled Trotter step of our jellium Hamiltonian. This circuit can be used as a building block of a larger phase estimation circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define a phase estimation circuit.</span>
<span class="k">def</span> <span class="nf">measure_bit_of_phase</span><span class="p">(</span><span class="n">system_qubits</span><span class="p">,</span>
                         <span class="n">control_qubit</span><span class="p">,</span>
                         <span class="n">controlled_unitary</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">controlled_unitary</span>
    <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">cirq</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">control_qubit</span><span class="p">)</span>

<span class="c1"># Get an upper bound on the Hamiltonian norm.</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">bound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">one_body</span><span class="p">))</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">two_body</span><span class="p">))</span>

<span class="c1"># Construct phase estimation circuit.</span>
<span class="n">time</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">bound</span>
<span class="n">control</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">LineQubit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">controlled_unitary</span> <span class="o">=</span> <span class="n">openfermion</span><span class="o">.</span><span class="n">simulate_trotter</span><span class="p">(</span>
    <span class="n">qubits</span><span class="p">,</span> <span class="n">hamiltonian</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span>
    <span class="n">n_steps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">algorithm</span><span class="o">=</span><span class="n">trotter</span><span class="o">.</span><span class="n">LINEAR_SWAP_NETWORK</span><span class="p">,</span>
    <span class="n">control_qubit</span><span class="o">=</span><span class="n">control</span><span class="p">)</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">cirq</span><span class="o">.</span><span class="n">Circuit</span><span class="p">(</span>
    <span class="n">measure_bit_of_phase</span><span class="p">(</span>
        <span class="n">qubits</span><span class="p">,</span>
        <span class="n">control</span><span class="p">,</span>
        <span class="n">controlled_unitary</span><span class="p">))</span>

<span class="c1"># Print the circuit.</span>
<span class="n">circuit</span><span class="o">=</span><span class="n">cirq</span><span class="o">.</span><span class="n">drop_negligible_operations</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circuit</span><span class="o">.</span><span class="n">to_text_diagram</span><span class="p">(</span><span class="n">transpose</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./myenv/openfermion/docs/tutorials"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> 目次
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Copyright 2020 The OpenFermion Developers</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#circuits-2-linear-trotter-steps-of-diagonal-coulomb-operators">Circuits 2: Linear Trotter steps of diagonal Coulomb operators</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setup">Setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#electronic-structure-hamiltonians-with-diagonal-coulomb-operators">Electronic structure Hamiltonians with diagonal Coulomb operators</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#generation-of-a-dual-basis-jellium-hamiltonian">Generation of a dual basis jellium Hamiltonian</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#initializing-the-mean-field-state-of-jellium">Initializing the mean-field state of jellium</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hamiltonian-simulation-via-a-trotter-suzuki-product-formula">Hamiltonian simulation via a Trotter-Suzuki product formula</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#application-to-phase-estimation">Application to phase estimation</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  © Copyright 2025-present by 吉田 聡太 (Sota Yoshida). 本コンテンツは<a rel="license" href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0 ライセンス</a>の下に提供されています。 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="クリエイティブ・コモンズ・ライセンス" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a>　ただし、資料中のコードセル部分は<a rel="license" href="https://opensource.org/licenses/MIT">MITライセンス</a>の下に提供されています。

</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>